{"version":3,"sources":["memoize.ts"],"names":[],"mappings":";;;IAMA,IAAM,YAAY,GAAG,EAAE,CAAC;IACxB,IAAM,WAAW,GAAG,EAAE,CAAC;IAEvB,uBAAuB,GAAQ;QAC7B,EAAE,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC;YACT,MAAM,CAAC,YAAY,CAAC;QACtB,CAAC;QAAC,IAAI,CAAC,EAAE,CAAC,CAAC,OAAO,GAAG,KAAK,QAAQ,CAAC,CAAC,CAAC;YACnC,MAAM,CAAC,GAAG,CAAC;QACb,CAAC;QAAC,IAAI,CAAC,EAAE,CAAC,CAAC,CAAC,WAAW,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;YAC7B,WAAW,CAAC,GAAG,CAAC,GAAG,EAAE,CAAC;QACxB,CAAC;QAED,MAAM,CAAC,WAAW,CAAC,GAAG,CAAC,CAAC;IAC1B,CAAC;IAED,iBAA0E,EAAK;QAC7E,IAAI,KAAU,CAAC;QAEf,kDAAkD;QAClD,MAAM,CAAC;YAA0B,cAAc;iBAAd,UAAc,EAAd,qBAAc,EAAd,IAAc;gBAAd,yBAAc;;YAC7C,IAAI,MAAgB,CAAC;YAErB,EAAE,CAAC,CAAC,IAAI,CAAC,MAAM,KAAK,CAAC,CAAC,CAAC,CAAC;gBACtB,EAAE,CAAC,CAAC,KAAK,KAAK,SAAS,CAAC,CAAC,CAAC;oBACxB,KAAK,GAAG,EAAE,eAAI,IAAI,CAAC,CAAC;gBACtB,CAAC;gBACD,MAAM,GAAG,KAAK,CAAC;YACjB,CAAC;YAAC,IAAI,CAAC,CAAC;gBACN,EAAE,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC;oBACX,KAAK,GAAG,IAAI,OAAO,EAAE,CAAC;gBACxB,CAAC;gBAED,IAAI,YAAY,GAAQ,KAAK,CAAC;gBAE9B,GAAG,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC;oBACzC,IAAI,GAAG,GAAG,aAAa,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC;oBAEjC,EAAE,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC;wBACT,GAAG,GAAG,YAAY,CAAC;oBACrB,CAAC;oBACD,EAAE,CAAC,CAAC,KAAK,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;wBACnB,YAAY,GAAG,KAAK,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;oBAChC,CAAC;oBAAC,IAAI,CAAC,CAAC;wBACN,YAAY,GAAG,IAAI,OAAO,EAAE,CAAC;wBAC7B,KAAK,CAAC,GAAG,CAAC,GAAG,EAAE,YAAY,CAAC,CAAC;oBAC/B,CAAC;gBACH,CAAC;gBAED,IAAI,OAAO,GAAG,aAAa,CAAC,IAAI,CAAC,IAAI,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC;gBAEnD,EAAE,CAAC,CAAC,YAAY,CAAC,GAAG,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC;oBAC9B,MAAM,GAAG,YAAY,CAAC,GAAG,CAAC,OAAO,CAAC,CAAC;gBACrC,CAAC;gBAAC,IAAI,CAAC,CAAC;oBACN,IAAI,KAAK,GAAG,EAAE,eAAI,IAAI,CAAC,CAAC;oBACxB,YAAY,CAAC,GAAG,CAAC,OAAO,EAAE,KAAK,CAAC,CAAC;oBACjC,MAAM,GAAG,KAAK,CAAC;gBACjB,CAAC;YACH,CAAC;YAED,MAAM,CAAC,MAAM,CAAC;QAChB,CAAQ,CAAC;IACX,CAAC;IA9CD,0BA8CC","file":"memoize.js","sourcesContent":["declare class WeakMap {\n  public get(key: any): any;\n  public set(key: any, value: any): void;\n  public has(key: any);\n}\n\nconst _emptyObject = {};\nconst _dictionary = {};\n\nfunction _normalizeArg(val: any) {\n  if (!val) {\n    return _emptyObject;\n  } else if (typeof val === 'object') {\n    return val;\n  } else if (!_dictionary[val]) {\n    _dictionary[val] = {};\n  }\n\n  return _dictionary[val];\n}\n\nexport function memoize<T extends (...args: any[]) => RET_TYPE, RET_TYPE>(cb: T): T {\n  let cache: any;\n\n  // tslint:disable-next-line:no-function-expression\n  return function memoizedFunction(...args: any[]): RET_TYPE {\n    let retVal: RET_TYPE;\n\n    if (args.length === 0) {\n      if (cache === undefined) {\n        cache = cb(...args);\n      }\n      retVal = cache;\n    } else {\n      if (!cache) {\n        cache = new WeakMap();\n      }\n\n      let currentCache: any = cache;\n\n      for (let i = 0; i < args.length - 1; i++) {\n        let arg = _normalizeArg(args[i]);\n\n        if (!arg) {\n          arg = _emptyObject;\n        }\n        if (cache.has(arg)) {\n          currentCache = cache.get(arg);\n        } else {\n          currentCache = new WeakMap();\n          cache.set(arg, currentCache);\n        }\n      }\n\n      let lastArg = _normalizeArg(args[args.length - 1]);\n\n      if (currentCache.has(lastArg)) {\n        retVal = currentCache.get(lastArg);\n      } else {\n        let value = cb(...args);\n        currentCache.set(lastArg, value);\n        retVal = value;\n      }\n    }\n\n    return retVal;\n  } as any;\n}\n"],"sourceRoot":"../src"}